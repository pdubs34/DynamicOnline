/*                       *
 * DO NOT EDIT THIS FILE *
 *                       */

/*
 * IntegerLab (c) 2018-21 Christopher A. Bohn
 */

/******************************************************************************
 * This program drives alu.c through the grading checklist.
 ******************************************************************************/

#include <stdio.h>
#include <time.h>
#include <string.h>
#include "alu.h"

char grading_category_string[64];
char input_string[64];
char expected_string[64];
char result_string[64];

void print_header();
void print_report();
uint16_t get_random(uint16_t lower_bound, uint16_t upper_bound);
uint16_t get_threshold_power_of_two(uint16_t multiplicand, uint16_t max_product);
bool sums_are_equal(addition_subtraction_result expected, addition_subtraction_result actual);
bool products_are_equal(multiplication_result expected, multiplication_result actual);
bool quotients_are_equal(division_result expected, division_result actual);
int print_sum_outcome(addition_subtraction_result *expected, addition_subtraction_result *actual);
int print_product_outcome(multiplication_result *expected, multiplication_result *actual);

int unsigned_additive_identity();
int unsigned_addition();
int unsigned_addition_without_overflow();
int unsigned_addition_with_overflow();
int unsigned_subtractive_identity();
int unsigned_subtraction();
int unsigned_zero_difference();
int unsigned_negative_difference();
int multiplicative_identity();
int multiplicative_zero();
int multiply_power_of_two();
int multiply_not_power_of_two();
int multiply_without_overflow_power_of_two();
int multiply_without_overflow_not_power_of_two();
int multiply_with_overflow_power_of_two();
int multiply_with_overflow_not_power_of_two();
int divisive_identity();
int divides_self();
int divisive_zero();
int division_by_zero();
int dividend_power_of_two();
int divisor_power_of_two();
int division_by_factor();
int division_arbitrary();
int signed_additive_identity();
int signed_add_positive();
int signed_add_without_overflow();
int signed_add_overflow();
int signed_add_negative();
int signed_subtractive_identity();
int signed_sub_positive_difference();
int signed_sub_negative_difference();
int signed_sub_negative();
int signed_sub_overflow();


int main(void) {
    int score = 0;
    srand((unsigned int)time(NULL)); // NOLINT(cert-msc51-cpp)

    printf("UNSIGNED ARITHMETIC\n");
    print_header();
    is_signed = false;
    score += unsigned_additive_identity();
    score += unsigned_addition();
    score += unsigned_addition_without_overflow();
    score += unsigned_addition_with_overflow();
    score += unsigned_subtractive_identity();
    score += unsigned_subtraction();
    score += unsigned_zero_difference();
    score += unsigned_negative_difference();
    score += multiplicative_identity();
    score += multiplicative_zero();
    score += multiply_power_of_two();
    score += multiply_not_power_of_two();
    score += multiply_without_overflow_power_of_two();
    score += multiply_without_overflow_not_power_of_two();
    score += multiply_with_overflow_power_of_two();
    score += multiply_with_overflow_not_power_of_two();
    score += divisive_identity();
    score += divides_self();
    score += divisive_zero();
    score += division_by_zero();
    score += dividend_power_of_two();
    score += divisor_power_of_two();
    score += division_by_factor();
    score += division_arbitrary();

    printf("\nSIGNED ARITHMETIC\n");
    print_header();
    is_signed = true;
    score += signed_additive_identity();
    score += signed_add_positive();
    score += signed_add_without_overflow();
    score += signed_add_overflow();
    score += signed_add_negative();
    score += signed_subtractive_identity();
    score += signed_sub_positive_difference();
    score += signed_sub_negative_difference();
    score += signed_sub_negative();
    score += signed_sub_overflow();

    printf("\nSCORE: %d/40.\n", score);
    printf("Run \"make operatorcheck\" and visually inspect alu.c for inappropriate arithmetic operators.\n");
    printf("Examine multiply() and divide() for superpolynomial algorithms.\n");
    return 0;
}

void print_header() {
    printf("%-28s%-16s%-27s%s\n", "Grading category", "Input", "Expected", "Result");
    printf("%-28s%-16s%-27s%s\n", "----------------", "-----", "--------", "------");
}

void print_report() {
    printf("%-28s%-16s%-27s%s\n", grading_category_string, input_string, expected_string, result_string);
}

uint16_t get_random(uint16_t lower_bound, uint16_t upper_bound) {
    return (uint16_t)(rand() % (upper_bound - lower_bound + 1)) + lower_bound; // NOLINT(cert-msc50-cpp)
}

uint16_t get_threshold_power_of_two(uint16_t multiplicand, uint16_t max_product) {
    uint16_t max_multiplier = max_product / multiplicand;
    int max_power = 0;
    while (max_multiplier > 1) {
        max_multiplier = max_multiplier >> 1;
        max_power++;
    }
    return (uint16_t)max_power;
}

bool sums_are_equal(addition_subtraction_result expected, addition_subtraction_result actual) {
    bool are_equal = (expected.result == actual.result);
    are_equal &= (expected.overflow == actual.overflow);
    return are_equal;
}

bool products_are_equal(multiplication_result expected, multiplication_result actual) {
    bool are_equal = (expected.product == actual.product);
    are_equal &= (expected.full_product == actual.full_product);
    are_equal &= (expected.overflow == actual.overflow);
    return are_equal;
}

bool quotients_are_equal(division_result expected, division_result actual) {
    if (expected.division_by_zero) {
        return actual.division_by_zero;
    } else {
        bool are_equal = (expected.quotient == actual.quotient);
        are_equal &= (expected.remainder == actual.remainder);
        are_equal &= !actual.division_by_zero;
        return are_equal;
    }
}

int print_sum_outcome(addition_subtraction_result *expected, addition_subtraction_result *actual) {
    if (sums_are_equal(*expected, *actual)) {
        sprintf(result_string, "PASS");
        return 2;
    } else {
        sprintf(result_string, "FAIL  Actual: %d %s", actual->result, actual->overflow ? "overflow" : "no overflow");
        return 0;
    }
}

int print_product_outcome(multiplication_result *expected, multiplication_result *actual) {
    if (products_are_equal(*expected, *actual)) {
        sprintf(result_string, "PASS");
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d %d %s", actual->product, actual->full_product, actual->overflow ?
                                                                                                "overflow" :
                                                                                                "no overflow");
        return 0;
    }
}

int unsigned_additive_identity() {
    strcpy(grading_category_string, "Additive identity");
    uint16_t operand1 = get_random(1, UINT16_MAX - 1);
    uint16_t operand2 = 0;
    sprintf(input_string, "%d + %d", operand1, operand2);
    addition_subtraction_result expected;
    expected.result = operand1 + operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", expected.result);
    addition_subtraction_result actual = add(operand1, operand2);
    if (actual.result == expected.result) {
        strcpy(result_string, "PASS");
        print_report();
        return 2;
    } else {
        sprintf(result_string, "FAIL  Actual: %d", actual.result);
        print_report();
        return 0;
    }
}

int unsigned_addition() {
    strcpy(grading_category_string, "Performs addition");
    uint16_t operand1 = get_random(1, UINT16_MAX - 1);
    uint16_t operand2 = get_random(1, (uint16_t)(UINT16_MAX - operand1 - 1));
    sprintf(input_string, "%d + %d", operand1, operand2);
    addition_subtraction_result expected;
    expected.result = operand1 + operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", expected.result);
    addition_subtraction_result actual = add(operand1, operand2);
    if (actual.result == expected.result) {
        strcpy(result_string, "PASS");
        print_report();
        return 2;
    } else {
        sprintf(result_string, "FAIL  Actual: %d", actual.result);
        print_report();
        return 0;
    }
}

int unsigned_addition_without_overflow() {
    strcpy(grading_category_string, "Add doesn't overflow");
    uint16_t least_sum = (uint16_t)(2 << 15);
    uint16_t operand1 = get_random(1, UINT16_MAX - 100);
    uint16_t operand2;
    if (operand1 < least_sum) {
        operand2 = get_random(least_sum - operand1, (uint16_t)(UINT16_MAX - operand1 - 1));
    } else {
        operand2 = get_random(1, (uint16_t)(UINT16_MAX - operand1 - 1));
    }
    sprintf(input_string, "%d + %d", operand1, operand2);
    addition_subtraction_result expected;
    expected.result = operand1 + operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d %s", expected.result, expected.overflow ? "overflow" : "no overflow");
    addition_subtraction_result actual = add(operand1, operand2);
    int score = print_sum_outcome(&expected, &actual);
    print_report();
    return score;
}

int unsigned_addition_with_overflow() {
    strcpy(grading_category_string, "Add overflows");
    uint16_t operand1 = get_random(10, UINT16_MAX - 10);
    uint16_t operand2 = get_random((uint16_t)(UINT16_MAX - operand1 + 2), UINT16_MAX);
    sprintf(input_string, "%d + %d", operand1, operand2);
    addition_subtraction_result expected;
    expected.result = operand1 + operand2;
    expected.overflow = true;
    sprintf(expected_string, "%d %s", expected.result, expected.overflow ? "overflow" : "no overflow");
    addition_subtraction_result actual = add(operand1, operand2);
    int score = print_sum_outcome(&expected, &actual);
    print_report();
    return score;
}

int unsigned_subtractive_identity() {
    strcpy(grading_category_string, "Subtractive identity");
    uint16_t operand1 = get_random(1, UINT16_MAX - 1);
    uint16_t operand2 = 0;
    sprintf(input_string, "%d - %d", operand1, operand2);
    addition_subtraction_result expected;
    expected.result = operand1 - operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", expected.result);
    addition_subtraction_result actual = subtract(operand1, operand2);
    if (actual.result == expected.result) {
        strcpy(result_string, "PASS");
        print_report();
        return 2;
    } else {
        sprintf(result_string, "FAIL  Actual: %d", actual.result);
        print_report();
        return 0;
    }
}

int unsigned_subtraction() {
    strcpy(grading_category_string, "Performs subtraction");
    uint16_t operand1 = get_random(10, UINT16_MAX - 1);
    uint16_t operand2 = get_random(1, (uint16_t)(UINT16_MAX - operand1 - 1));
    sprintf(input_string, "%d - %d", operand1, operand2);
    addition_subtraction_result expected;
    expected.result = operand1 - operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", expected.result);
    addition_subtraction_result actual = subtract(operand1, operand2);
    if (actual.result == expected.result) {
        strcpy(result_string, "PASS");
        print_report();
        return 2;
    } else {
        sprintf(result_string, "FAIL  Actual: %d", actual.result);
        print_report();
        return 0;
    }
}

int unsigned_zero_difference() {
    strcpy(grading_category_string, "Sub doesn't overflow");
    uint16_t operand1 = get_random(10, UINT16_MAX - 10);
    uint16_t operand2 = operand1;
    sprintf(input_string, "%d - %d", operand1, operand2);
    addition_subtraction_result expected;
    expected.result = operand1 - operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d %s", expected.result, expected.overflow ? "overflow" : "no overflow");
    addition_subtraction_result actual = subtract(operand1, operand2);
    int score = print_sum_outcome(&expected, &actual);
    print_report();
    return score;
}

int unsigned_negative_difference() {
    strcpy(grading_category_string, "Sub overflows");
    uint16_t operand1 = get_random(10, UINT16_MAX - 10);
    uint16_t operand2 = get_random((uint16_t)(operand1 - 1), UINT16_MAX);
    sprintf(input_string, "%d - %d", operand1, operand2);
    addition_subtraction_result expected;
    expected.result = operand1 - operand2;
    expected.overflow = true;
    sprintf(expected_string, "%d %s", expected.result, expected.overflow ? "overflow" : "no overflow");
    addition_subtraction_result actual = subtract(operand1, operand2);
    int score = print_sum_outcome(&expected, &actual);
    print_report();
    return score;
}

int multiplicative_identity() {
    strcpy(grading_category_string, "Multiplicative identity");
    uint16_t operand1 = get_random(1, UINT16_MAX - 1);
    uint16_t operand2 = 1;
    sprintf(input_string, "%d * %d", operand1, operand2);
    multiplication_result expected;
    expected.product = operand1 * operand2;
    expected.full_product = operand1 * operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", expected.product);
    multiplication_result actual = multiply(operand1, operand2);
    if (actual.product == expected.product) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d", actual.product);
        print_report();
        return 0;
    }
}

int multiplicative_zero() {
    strcpy(grading_category_string, "Multiplicative zero");
    uint16_t operand1 = get_random(1, UINT16_MAX - 1);
    uint16_t operand2 = 0;
    sprintf(input_string, "%d * %d", operand1, operand2);
    multiplication_result expected;
    expected.product = operand1 * operand2;
    expected.full_product = operand1 * operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", expected.product);
    multiplication_result actual = multiply(operand1, operand2);
    if (actual.product == expected.product) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d", actual.product);
        print_report();
        return 0;
    }
}

int multiply_power_of_two() {
    strcpy(grading_category_string, "Mul power of two");
    uint16_t operand1 = get_random(1, UINT16_MAX / 2);
    int power = get_random(1, get_threshold_power_of_two(operand1, UINT16_MAX));
    uint16_t operand2 = (uint16_t)(1 << power);
    sprintf(input_string, "%d * %d", operand1, operand2);
    multiplication_result expected;
    expected.product = operand1 * operand2;
    expected.full_product = operand1 * operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", expected.product);
    multiplication_result actual = multiply(operand1, operand2);
    if (actual.product == expected.product) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d", actual.product);
        print_report();
        return 0;
    }
}

int multiply_not_power_of_two() {
    strcpy(grading_category_string, "Mul not power of two");
    uint16_t operand1 = get_random(2, UINT16_MAX / 2);
    uint16_t operand2 = get_random(2, (uint16_t)(UINT16_MAX / operand1));
    if (operand2 == 2) {
        operand2++;
    }
    for (int i = 2; i < 16; i++) {
        if (operand2 == 1 << i) {
            operand2--;
        }
    }
    sprintf(input_string, "%d * %d", operand1, operand2);
    multiplication_result expected;
    expected.product = operand1 * operand2;
    expected.full_product = operand1 * operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", expected.product);
    multiplication_result actual = multiply(operand1, operand2);
    if (actual.product == expected.product) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d", actual.product);
        print_report();
        return 0;
    }
}

int multiply_without_overflow_power_of_two() {
    strcpy(grading_category_string, "Mul 2^n w/o overflow");
    uint16_t operand1 = get_random(1, UINT16_MAX / 2);
    int power = get_random(1, get_threshold_power_of_two(operand1, UINT16_MAX));
    uint16_t operand2 = (uint16_t)(1 << power);
    sprintf(input_string, "%d * %d", operand1, operand2);
    multiplication_result expected;
    expected.product = operand1 * operand2;
    expected.full_product = operand1 * operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d %d %s", expected.product, expected.full_product, expected.overflow ? "overflow" : "no overflow");
    multiplication_result actual = multiply(operand1, operand2);
    int score = print_product_outcome(&expected, &actual);
    print_report();
    return score;
}

int multiply_without_overflow_not_power_of_two() {
    strcpy(grading_category_string, "Mul !2^n w/o overflow");
    uint16_t operand1 = get_random(2, UINT16_MAX / 3);
    uint16_t operand2 = get_random(2, (uint16_t)(UINT16_MAX / operand1));
    if (operand2 == 2) {
        operand2++;
    }
    for (int i = 2; i < 16; i++) {
        if (operand2 == 1 << i) {
            operand2--;
        }
    }
    sprintf(input_string, "%d * %d", operand1, operand2);
    multiplication_result expected;
    expected.product = operand1 * operand2;
    expected.full_product = operand1 * operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d %d %s", expected.product, expected.full_product, expected.overflow ? "overflow" : "no overflow");
    multiplication_result actual = multiply(operand1, operand2);
    int score = print_product_outcome(&expected, &actual);
    print_report();
    return score;
}

int multiply_with_overflow_power_of_two() {
    strcpy(grading_category_string, "Mul 2^n with overflow");
    uint16_t operand1 = get_random(1, UINT16_MAX - 1);
    int power = get_random(get_threshold_power_of_two(operand1, UINT16_MAX) + (uint16_t)1, 15);
    uint16_t operand2 = (uint16_t)(1 << power);
    sprintf(input_string, "%d * %d", operand1, operand2);
    multiplication_result expected;
    expected.product = operand1 * operand2;
    expected.full_product = operand1 * operand2;
    expected.overflow = true;
    sprintf(expected_string, "%d %d %s", expected.product, expected.full_product, expected.overflow ? "overflow" : "no overflow");
    multiplication_result actual = multiply(operand1, operand2);
    int score = print_product_outcome(&expected, &actual);
    print_report();
    return score;
}

int multiply_with_overflow_not_power_of_two() {
    strcpy(grading_category_string, "Mul !2^n with overflow");
    uint16_t operand1 = get_random(2, UINT16_MAX - 1);
    uint16_t operand2 = get_random((uint16_t)(UINT16_MAX / operand1), UINT16_MAX);
    if (operand2 == 2) {
        operand2++;
    }
    for (int i = 2; i < 16; i++) {
        if (operand2 == 1 << i) {
            operand2--;
        }
    }
    sprintf(input_string, "%d * %d", operand1, operand2);
    multiplication_result expected;
    expected.product = operand1 * operand2;
    expected.full_product = operand1 * operand2;
    expected.overflow = true;
    sprintf(expected_string, "%d %d %s", expected.product, expected.full_product, expected.overflow ? "overflow" : "no overflow");
    multiplication_result actual = multiply(operand1, operand2);
    int score = print_product_outcome(&expected, &actual);
    print_report();
    return score;
}

int divisive_identity() {
    strcpy(grading_category_string, "Divisive identity");
    uint16_t operand1 = get_random(1, UINT16_MAX - 1);
    uint16_t operand2 = 1;
    sprintf(input_string, "%d / %d", operand1, operand2);
    division_result expected;
    expected.quotient = operand1 / operand2;
    expected.remainder = operand1 % operand2;
    expected.division_by_zero = false;
    sprintf(expected_string, "%d r%d", expected.quotient, expected.remainder);
    division_result actual = divide(operand1, operand2);
    if (quotients_are_equal(expected, actual)) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d r%d, Division-by-Zero: %s",
                actual.quotient, actual.remainder, actual.division_by_zero ? "true" : "false");
        print_report();
        return 0;
    }
}

int divides_self() {
    strcpy(grading_category_string, "Divides self");
    uint16_t operand1 = get_random(1, UINT16_MAX - 1);
    uint16_t operand2 = operand1;
    sprintf(input_string, "%d / %d", operand1, operand2);
    division_result expected;
    expected.quotient = operand1 / operand2;
    expected.remainder = operand1 % operand2;
    expected.division_by_zero = false;
    sprintf(expected_string, "%d r%d", expected.quotient, expected.remainder);
    division_result actual = divide(operand1, operand2);
    if (quotients_are_equal(expected, actual)) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d r%d, Division-by-Zero: %s",
                actual.quotient, actual.remainder, actual.division_by_zero ? "true" : "false");
        print_report();
        return 0;
    }
}

int divisive_zero() {
    strcpy(grading_category_string, "Divisive zero");
    uint16_t operand2 = get_random(1, UINT16_MAX - 1);
    uint16_t operand1 = 0;
    sprintf(input_string, "%d / %d", operand1, operand2);
    division_result expected;
    expected.quotient = operand1 / operand2;
    expected.remainder = operand1 % operand2;
    expected.division_by_zero = false;
    sprintf(expected_string, "%d r%d", expected.quotient, expected.remainder);
    division_result actual = divide(operand1, operand2);
    if (quotients_are_equal(expected, actual)) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d r%d, Division-by-Zero: %s",
                actual.quotient, actual.remainder, actual.division_by_zero ? "true" : "false");
        print_report();
        return 0;
    }
}

int division_by_zero() {
    strcpy(grading_category_string, "Division by zero");
    uint16_t operand1 = get_random(1, UINT16_MAX - 1);
    uint16_t operand2 = 0;
    sprintf(input_string, "%d / %d", operand1, operand2);
    division_result expected;
    expected.quotient = 0;
    expected.remainder = 0;
    expected.division_by_zero = true;
    sprintf(expected_string, "%d r%d", expected.quotient, expected.remainder);
    division_result actual = divide(operand1, operand2);
    if (quotients_are_equal(expected, actual)) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d r%d, Division-by-Zero: %s",
                actual.quotient, actual.remainder, actual.division_by_zero ? "true" : "false");
        print_report();
        return 0;
    }
}

int dividend_power_of_two() {
    strcpy(grading_category_string, "Dividend is power of two");
    int power = get_random(3, 15);
    uint16_t operand1 = (uint16_t)(1 << power);
    power = get_random(2, (uint16_t)(power - 1));
    uint16_t operand2 = (uint16_t)(1 << power);
    sprintf(input_string, "%d / %d", operand1, operand2);
    division_result expected;
    expected.quotient = operand1 / operand2;
    expected.remainder = operand1 % operand2;
    expected.division_by_zero = false;
    sprintf(expected_string, "%d r%d", expected.quotient, expected.remainder);
    division_result actual = divide(operand1, operand2);
    if (quotients_are_equal(expected, actual)) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d r%d, Division-by-Zero: %s",
                actual.quotient, actual.remainder, actual.division_by_zero ? "true" : "false");
        print_report();
        return 0;
    }
}

int divisor_power_of_two() {
    strcpy(grading_category_string, "Div by power of two");
    uint16_t operand1 = get_random(10, UINT16_MAX - 1);
    int power = get_random(1, get_threshold_power_of_two(2, (uint16_t)(operand1 - 1)));
    uint16_t operand2 = (uint16_t)(1 << power);
    sprintf(input_string, "%d / %d", operand1, operand2);
    division_result expected;
    expected.quotient = operand1 / operand2;
    expected.remainder = operand1 % operand2;
    expected.division_by_zero = false;
    sprintf(expected_string, "%d r%d", expected.quotient, expected.remainder);
    division_result actual = divide(operand1, operand2);
    if (quotients_are_equal(expected, actual)) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d r%d, Division-by-Zero: %s",
                actual.quotient, actual.remainder, actual.division_by_zero ? "true" : "false");
        print_report();
        return 0;
    }
}

int division_by_factor() {
    strcpy(grading_category_string, "Div by factor");
    uint16_t operand2 = get_random(3, UINT16_MAX / 3);
    uint16_t operand1 = operand2 * get_random(2, (uint16_t)(UINT16_MAX / operand2));
    sprintf(input_string, "%d / %d", operand1, operand2);
    division_result expected;
    expected.quotient = operand1 / operand2;
    expected.remainder = operand1 % operand2;
    expected.division_by_zero = false;
    sprintf(expected_string, "%d r%d", expected.quotient, expected.remainder);
    division_result actual = divide(operand1, operand2);
    if (quotients_are_equal(expected, actual)) {
        strcpy(result_string, "BONUS!");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "NO BONUS  Actual: %d r%d, Division-by-Zero: %s",
                actual.quotient, actual.remainder, actual.division_by_zero ? "true" : "false");
        print_report();
        return 0;
    }
}

int division_arbitrary() {
    strcpy(grading_category_string, "Div by arbitrary value");
    uint16_t operand1 = get_random(3, UINT16_MAX - 1);
    uint16_t operand2 = get_random(2, (uint16_t)(operand1 - 1));
    sprintf(input_string, "%d / %d", operand1, operand2);
    division_result expected;
    expected.quotient = operand1 / operand2;
    expected.remainder = operand1 % operand2;
    expected.division_by_zero = false;
    sprintf(expected_string, "%d r%d", expected.quotient, expected.remainder);
    division_result actual = divide(operand1, operand2);
    if (quotients_are_equal(expected, actual)) {
        strcpy(result_string, "BONUS!");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "NO BONUS  Actual: %d r%d, Division-by-Zero: %s",
                actual.quotient, actual.remainder, actual.division_by_zero ? "true" : "false");
        print_report();
        return 0;
    }
}

int signed_additive_identity() {
    strcpy(grading_category_string, "Additive identity");
    uint16_t operand1 = get_random(1, INT16_MAX - 1);
    uint16_t operand2 = 0;
    sprintf(input_string, "%d + %d", (int16_t)operand1, (int16_t)operand2);
    addition_subtraction_result expected;
    expected.result = operand1 + operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", (int16_t)expected.result);
    addition_subtraction_result actual = add(operand1, operand2);
    if (actual.result == expected.result) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d", (int16_t)actual.result);
        print_report();
        return 0;
    }
}

int signed_add_positive() {
    strcpy(grading_category_string, "Adds positive values");
    uint16_t operand1 = get_random(1, INT16_MAX - 1);
    uint16_t operand2 = get_random(1, (uint16_t)(INT16_MAX - operand1 - 1));
    sprintf(input_string, "%d + %d", (int16_t)operand1, (int16_t)operand2);
    addition_subtraction_result expected;
    expected.result = operand1 + operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", (int16_t)expected.result);
    addition_subtraction_result actual = add(operand1, operand2);
    if (actual.result == expected.result) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d", (int16_t)actual.result);
        print_report();
        return 0;
    }
}

int signed_add_without_overflow() {
    strcpy(grading_category_string, "Add doesn't overflow");
    uint16_t least_sum = (int16_t)(2 << 7);
    uint16_t operand1 = get_random(1, INT16_MAX - 100);
    uint16_t operand2;
    if (operand1 < least_sum) {
        operand2 = get_random(least_sum - operand1, (uint16_t)(INT16_MAX - operand1 - 1));
    } else {
        operand2 = get_random(1, (uint16_t)(INT16_MAX - operand1 - 1));
    }
    sprintf(input_string, "%d + %d", (int16_t)operand1, (int16_t)operand2);
    addition_subtraction_result expected;
    expected.result = operand1 + operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", (int16_t)expected.result);
    addition_subtraction_result actual = add(operand1, operand2);
    if (sums_are_equal(expected, actual)) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d %s", (int16_t)actual.result, actual.overflow ? "overflow" : "no overflow");
        print_report();
        return 0;
    }
}

int signed_add_overflow() {
    strcpy(grading_category_string, "Add overflows");
    uint16_t operand1 = get_random(10, INT16_MAX - 10);
    uint16_t operand2 = get_random((uint16_t)(INT16_MAX - operand1 + 2), INT16_MAX);
    sprintf(input_string, "%d + %d", (int16_t)operand1, (int16_t)operand2);
    addition_subtraction_result expected;
    expected.result = operand1 + operand2;
    expected.overflow = true;
    sprintf(expected_string, "%d %s", (int16_t)expected.result, expected.overflow ? "overflow" : "no overflow");
    addition_subtraction_result actual = add(operand1, operand2);
    if (sums_are_equal(expected, actual)) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d %s", (int16_t)actual.result, actual.overflow ? "overflow" : "no overflow");
        print_report();
        return 0;
    }
}

int signed_add_negative() {
    strcpy(grading_category_string, "Add to negative augend");
    uint16_t operand1 = get_random((uint16_t)INT16_MIN, (uint16_t)-1);
    uint16_t operand2 = get_random(1, INT16_MAX);
    sprintf(input_string, "%d + %d", (int16_t)operand1, (int16_t)operand2);
    addition_subtraction_result expected;
    expected.result = operand1 + operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d %s", (int16_t)expected.result, expected.overflow ? "overflow" : "no overflow");
    addition_subtraction_result actual = add(operand1, operand2);
    if (sums_are_equal(expected, actual)) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d %s", (int16_t)actual.result, actual.overflow ? "overflow" : "no overflow");
        print_report();
        return 0;
    }
}

int signed_subtractive_identity() {
    strcpy(grading_category_string, "Subtractive identity");
    uint16_t operand1 = get_random(1, INT16_MAX - 1);
    uint16_t operand2 = 0;
    sprintf(input_string, "%d - %d", (int16_t)operand1, (int16_t)operand2);
    addition_subtraction_result expected;
    expected.result = operand1 - operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", (int16_t)expected.result);
    addition_subtraction_result actual = subtract(operand1, operand2);
    if (actual.result == expected.result) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d", (int16_t)actual.result);
        print_report();
        return 0;
    }
}

int signed_sub_positive_difference() {
    strcpy(grading_category_string, "Sub positive difference");
    uint16_t operand1 = get_random(10, INT16_MAX - 1);
    uint16_t operand2 = get_random(1, operand1);
    sprintf(input_string, "%d - %d", (int16_t)operand1, (int16_t)operand2);
    addition_subtraction_result expected;
    expected.result = operand1 - operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", (int16_t)expected.result);
    addition_subtraction_result actual = subtract(operand1, operand2);
    if (actual.result == expected.result) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d", (int16_t)actual.result);
        print_report();
        return 0;
    }
}

int signed_sub_negative_difference() {
    strcpy(grading_category_string, "Sub negative difference");
    uint16_t operand2 = get_random(10, INT16_MAX - 1);
    uint16_t operand1 = get_random(1, operand2);
    sprintf(input_string, "%d - %d", (int16_t)operand1, (int16_t)operand2);
    addition_subtraction_result expected;
    expected.result = operand1 - operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", (int16_t)expected.result);
    addition_subtraction_result actual = subtract(operand1, operand2);
    if (sums_are_equal(expected, actual)) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d %s", (int16_t)actual.result, actual.overflow ? "overflow" : "no overflow");
        print_report();
        return 0;
    }
}

int signed_sub_negative() {
    strcpy(grading_category_string, "Sub from negative menuend");
    uint16_t operand1 = get_random((uint16_t)(INT16_MIN + 10), (uint16_t)-1);
    uint16_t operand2 = get_random(1, (uint16_t)(operand1 - INT16_MIN));
    sprintf(input_string, "%d - %d", (int16_t)operand1, (int16_t)operand2);
    addition_subtraction_result expected;
    expected.result = operand1 - operand2;
    expected.overflow = false;
    sprintf(expected_string, "%d", (int16_t)expected.result);
    addition_subtraction_result actual = subtract(operand1, operand2);
    if (sums_are_equal(expected, actual)) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d %s", (int16_t)actual.result, actual.overflow ? "overflow" : "no overflow");
        print_report();
        return 0;
    }
}

int signed_sub_overflow() {
    strcpy(grading_category_string, "Sub overflows");
    uint16_t operand1 = get_random((uint16_t)(INT16_MIN + 10), (uint16_t)-10);
    uint16_t operand2 = get_random((uint16_t)(operand1 - INT16_MIN), INT16_MAX);
    sprintf(input_string, "%d - %d", (int16_t)operand1, (int16_t)operand2);
    addition_subtraction_result expected;
    expected.result = operand1 - operand2;
    expected.overflow = true;
    sprintf(expected_string, "%d", (int16_t)expected.result);
    addition_subtraction_result actual = subtract(operand1, operand2);
    if (sums_are_equal(expected, actual)) {
        strcpy(result_string, "PASS");
        print_report();
        return 1;
    } else {
        sprintf(result_string, "FAIL  Actual: %d %s", (int16_t)actual.result, actual.overflow ? "overflow" : "no overflow");
        print_report();
        return 0;
    }
}
